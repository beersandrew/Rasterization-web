<!doctype html>
<html>
<head>
<title>Line Rasterization</title>
<script>
"use strict";
/*
* rasterize_line divides lines into fragments.
*  va: first vertex. Access coordinates as va.x, va.y.
*  vb: second vertex. Access coordinates as vb.x, vb.y.
*  emit_fragment: output function. Call as emit_fragment(cx,cy)
*   with pixel center of all pixels exited by line.
*
* Consider pixel (x,y) to be "exited" if the line from va-vb exits
* the diamond joining midpoint of each edge of the [x,x+1]x[y,y+1]
* box, i.e., (x+0.5,y)-(x+1,y+0.5)-(x+0.5,y+1)-(x,y+0.5) .
*
*/


function getSlope(vertexA, vertexB){
	const dx = vertexB.x - vertexA.x;
	const dy = vertexB.y - vertexA.y;
	return dy / dx;
}

function getLineContext(vertexA, vertexB){
	let dx = vertexB.x - vertexA.x;
	let dy = vertexB.y - vertexA.y;

	var context = {
		slope: dy / dx,
		vertexA: vertexA,
		vertexB: vertexB
	};

	if (Math.abs(context.slope) > 1) {
		if (dy < 0){
			context.vertexA = vertexB;
			context.vertexB = vertexA;

			dx = context.vertexB.x - context.vertexA.x;
			dy = context.vertexB.y - context.vertexA.y;
		}
		context.slope = dx / dy;
		context.iterating = { start: context.vertexA.y, end: context.vertexB.y}
		context.adjusting = { start: context.vertexA.x, end: context.vertexB.x}
		context.iteratingX = false;
	}
	else{
		if (dx < 0){
			context.vertexA = vertexB;
			context.vertexB = vertexA;
			dx = context.vertexB.x - context.vertexA.x;
			dy = context.vertexB.y - context.vertexA.y;
			context.slope = dy / dx;
		}
		context.iterating = { start: context.vertexA.x, end: context.vertexB.x}
		context.adjusting = { start: context.vertexA.y, end: context.vertexB.y}
		context.iteratingX = true;
	}

	return context;
}

function try_emit(vertex, emit_fragment){

	var centerOfFragmentToEmit = {
		x: Math.floor(vertex.x)+0.5, 
		y: Math.floor(vertex.y)+0.5
	};

	const key = centerOfFragmentToEmit.x + "." + centerOfFragmentToEmit.y;
	if (!(key in FRAGMENTS)) {
		emit_fragment(centerOfFragmentToEmit.x, centerOfFragmentToEmit.y);
	}
}

function AreInSamePixel(vertexA, vertexB){
	return Math.floor(vertexA.x) == Math.floor(vertexB.x) && Math.floor(vertexA.y) == Math.floor(vertexB.y);
}

function AreInSameQuadrant(vertexA, vertexB){
	const cx = Math.floor(vertexA.x) + 0.5;
	const cy = Math.floor(vertexA.y) + 0.5;

	const xComponentVertexA = vertexA.x - cx;
	const yComponentVertexA = vertexA.y - cy;
	const xComponentVertexB = vertexB.x - cx;
	const yComponentVertexB = vertexB.y - cy;

	if (((xComponentVertexA > 0 && xComponentVertexB > 0) || (xComponentVertexA < 0 && xComponentVertexB < 0)) && 
		((yComponentVertexA > 0 && yComponentVertexB > 0) || (yComponentVertexA < 0 && yComponentVertexB < 0))){
		return true;
	}

	return false;
}

function GetManhattanDistance(vertex){
	const cx = Math.floor(vertex.x) + 0.5;
	const xComponent = Math.abs(vertex.x - cx);
	const cy = Math.floor(vertex.y) + 0.5;
	const yComponent = Math.abs(vertex.y - cy);

	return xComponent + yComponent;
}

function IsInsideDiamondFull(vertex, isIteratingX){

	const cx = Math.floor(vertex.x) + 0.5;
	const xComponent = Math.abs(vertex.x - cx);
	const cy = Math.floor(vertex.y) + 0.5;
	const yComponent = Math.abs(vertex.y - cy);

	const manhattanDistance = xComponent + yComponent;

	console.log("manhattan distance: ", manhattanDistance)

	if (manhattanDistance < 0.5){
		return true;
	}

	if (manhattanDistance == 0.5){
		if (yComponent < 0){
			return true;
		}
		
		if (!isIteratingX){
			if (xComponent == 0.5){
				return true;
			}
		}
	}

	return false;
}

function IsInsideDiamond(manhattanDistance){
	return manhattanDistance < 0.5
}

function IsOnDiamond(manhattanDistance){
	return manhattanDistance == 0.5
}

function IsOutsideDiamond(manhattanDistance){
	return manhattanDistance > 0.5
}

function IsPointOnLine(vertex, line){

	const slope = getSlope(line.start, line.end);

	var result = slope * (vertex.x - line.start.x) + line.start.y;

	return vertex.y == result;
}

function IsOnInsideEdgeAndExiting(vertexA, vertexB){

	const diamondLines = GetDiamondLinesForPixel(vertexA);
	const vertexAOnBottomLeft = IsPointOnLine(vertexA, diamondLines.bottomLeft);
	const vertexAOnBottomRight = IsPointOnLine(vertexA, diamondLines.bottomRight);

	if (vertexAOnBottomLeft || vertexAOnBottomRight){
		if (!AreInSamePixel(vertexA, vertexB)){
			return true;
		}
		else {
			if (IsInsideDiamond(vertexB)){
				return false;
			}

			const vertexBOnBottomLeft = IsPointOnLine(vertexB, diamondLines.bottomLeft);

			if (vertexAOnBottomLeft && vertexBOnBottomLeft){
				return false;
			}
			
			const vertexBOnBottomRight = IsPointOnLine(vertexB, diamondLines.bottomRight);
			if (vertexAOnBottomRight && vertexAOnBottomRight){
				return false;
			}

			return true;
		}
	}

	return false;
}

function DoesLineCrossDiamond(rasterLine, vertex){
	const diamondLines = GetDiamondLinesForPixel(vertex);

	if (DoLinesCross(rasterLine, diamondLines.topLeft) || 
		DoLinesCross(rasterLine, diamondLines.topRight) || 
		DoLinesCross(rasterLine, diamondLines.bottomLeft) || 
		DoLinesCross(rasterLine, diamondLines.bottomRight)) {
		return true;
	}

	var bottomLeftResult = SolveForTandU(rasterLine, diamondLines.bottomLeft);

	console.log("bottomLeft: ", bottomLeftResult);

	var bottomRightResult = SolveForTandU(rasterLine, diamondLines.bottomRight);

	console.log("bottomRight: ", bottomRightResult);	

	return false;
}

function GetDiamondLinesForPixel(vertex){
	const topDiamondVertex = { x: Math.floor(vertex.x) + 0.5, y: Math.ceil(vertex.y)};
	const rightDiamondVertex = { x: Math.ceil(vertex.x), y: Math.floor(vertex.y) + 0.5 };
	const bottomDiamondVertex = { x: Math.floor(vertex.x) + 0.5, y: Math.floor(vertex.y)};
	const leftDiamondVertex = { x: Math.floor(vertex.x), y: Math.floor(vertex.y) + 0.5 };

	return {
		topRight: { start: topDiamondVertex, end: rightDiamondVertex},
		bottomRight: { start: bottomDiamondVertex, end: rightDiamondVertex},
		bottomLeft: { start: leftDiamondVertex, end: bottomDiamondVertex},
		topLeft: { start: leftDiamondVertex, end: topDiamondVertex}
	};
}

function SolveForTandU(lineA, lineB){
	// convert lines to a linear equation in the form Ax = b from parametric equations
	const determinantA = (lineB.end.x - lineB.start.x)*(lineA.end.y - lineA.start.y) - (lineA.end.x - lineA.start.x)*(lineB.end.y - lineB.start.y);
	const determinantAt = (lineB.end.x - lineB.start.x)*(lineB.start.y - lineA.start.y) - (lineB.start.x - lineA.start.x)*(lineB.end.y - lineB.start.y);
	const determinantAu = (lineA.end.x - lineA.start.x)*(lineB.start.y - lineA.start.y) - (lineB.start.x - lineA.start.x)*(lineA.end.y - lineA.start.y);

	return {
		t: determinantAt / determinantA,
		u: determinantAu / determinantA
	};
}

function DoLinesCross(lineA, lineB){
	const intersectionResult = SolveForTandU(lineA, lineB);
	return intersectionResult.t > 0 && intersectionResult.t < 1 && intersectionResult.u > 0 && intersectionResult.u < 1;
}

function IsOnDiamondBottom(vertex){
	return vertex.x == Math.floor(vertex.x) + 0.5 && vertex.y == Math.floor(vertex.y);
}

function IsOnDiamondLeft(vertex){
	return vertex.x == Math.floor(vertex.x) && vertex.y == Math.floor(vertex.y) + 0.5;
}

function rasterize_line( vertexA, vertexB, emit_fragment ) {

	const context = getLineContext(vertexA, vertexB);

	// if (AreInSamePixel(context.vertexA, context.vertexB)){

	// 	console.log("start and end in same pixel")

	// 	const vertexAManhattanDistance = GetManhattanDistance(context.vertexA);
	// 	const vertexBManhattanDistance = GetManhattanDistance(context.vertexB);

	// 	if (IsInsideDiamond(vertexAManhattanDistance) && IsInsideDiamond(vertexBManhattanDistance)){
	// 		console.log("both inside")
	// 		return;
	// 	}
	// 	else if (IsOutsideDiamond(vertexAManhattanDistance) && IsOutsideDiamond(vertexBManhattanDistance)){
	// 		if (AreInSameQuadrant(context.vertexA, context.vertexB)){
	// 			console.log("both outside, do not cross")
	// 		}
	// 		else {
	// 			console.log("emitting")
	// 			try_emit(context.vertexA, emit_fragment);
	// 		}
	// 		return;
	// 	}
	// 	else if (IsOnDiamondBottom(context.vertexA) || IsOnDiamondBottom(context.vertexB)){
	// 		try_emit(context.vertexA, emit_fragment);
	// 		return;
	// 	}
	// 	else if ((IsOnDiamondLeft(context.vertexA) || IsOnDiamondLeft(context.vertexB)) && !context.iteratingX){
	// 		console.log("slope steep")
	// 		const pixelLeftOfVertexA = {x: context.vertexA.x - 1, y: context.vertexA.y}
	// 		try_emit(pixelLeftOfVertexA, emit_fragment);
	// 		return;
	// 	}
	// 	else if (IsOnDiamond(vertexAManhattanDistance) && IsOnDiamond(vertexBManhattanDistance)){
	// 		return;
	// 	}
	// 	else if (DoesLineCrossDiamond({start: context.vertexA, end: context.vertexB}, vertexA)){
	// 		console.log("ONLY: CROSS - emit")
	// 		try_emit(context.vertexA, emit_fragment);
	// 		return;
	// 	}
	// 	else{
	// 		console.log("ONLY: no cross - same pixel")
	// 		return;
	// 	}
	// }

	console.log("context: ", context)
	for(var current_a = Math.floor(context.iterating.start) + 0.5; current_a <= Math.floor(context.iterating.end) + 0.5; current_a++){


		console.log("test point:", current_a)
		var isFirstIteration = current_a == Math.floor(context.iterating.start) + 0.5;
		var isLastIteration = (current_a + 1) > Math.floor(context.iterating.end) + 0.5;
		if (isFirstIteration){
			var isInside = IsInsideDiamondFull(context.vertexA, context.iteratingX);

			console.log("is inside: ", isInside);

			var doesCrossLine = DoesLineCrossDiamond({start: context.vertexA, end: context.vertexB}, context.vertexA);

			console.log("does cross: ", doesCrossLine)

			if (context.vertexA == vertexA){
			
				if (doesCrossLine || IsOnInsideEdgeAndExiting(context.vertexA, context.vertexB)){
					try_emit(context.vertexA, emit_fragment);
				}
			}
			else {
				if (!isInside && doesCrossLine){
					try_emit(context.vertexA, emit_fragment);
				}
			}



			// if (DoesLineCrossDiamond({start: context.vertexA, end: context.vertexB}, context.vertexA)){
			// 	console.log("INITIAL: CROSS - emit?")
			// 	try_emit(context.vertexA, emit_fragment);
			// }
			// else if (IsOnDiamondBottom(context.vertexA)){
			// 	try_emit(context.vertexA, emit_fragment);
			// }
			// else if (IsOnDiamondLeft(context.vertexA) && !context.iteratingX){
			// 	console.log("slope steep")
			// 	const pixelLeftOfVertexA = {x: context.vertexA.x - 1, y: context.vertexA.y}
			// 	try_emit(pixelLeftOfVertexA, emit_fragment);
			// }
			// else{
			// 	const current_b = Math.floor(context.slope * (current_a - context.iterating.start) + context.adjusting.start) + 0.5;

			// 	const vertex = context.iteratingX ? {x: current_a, y: current_b} : {x: current_b, y: current_a};

			// 	console.log("vertex: ", vertex)

			// 	// Vertical line goes to the left
			// 	if (!context.iteratingX && context.slope == 0 && context.vertexA.x == Math.floor(context.vertexA.x)){
			// 		vertex.x--;
			// 		try_emit(vertex, emit_fragment);
			// 	}
			// 	else {
			// 		if (vertex.x < context.vertexA.x && vertex.y < context.vertexA.y){
			// 			// we're not in the starting square
			// 			console.log(" first: stopped bad emit at: ", vertex)
			// 		}
			// 		else {
			// 			try_emit(vertex, emit_fragment);
			// 		}
			// 	}
				
			// }
		}
		else if (isLastIteration){
			var isInside = IsInsideDiamondFull(context.vertexB, context.iteratingX);

			console.log("is inside: ", isInside);

			var doesCrossLine = DoesLineCrossDiamond({start: context.vertexA, end: context.vertexB}, context.vertexB);

			console.log("does cross: ", doesCrossLine)

			if (context.vertexA == vertexA){
				if (!isInside && doesCrossLine){
					try_emit(context.vertexB, emit_fragment);
				}
				
			}
			else {
				if (doesCrossLine || IsOnDiamondBottom(context.vertexB) || IsOnInsideEdgeAndExiting(context.vertexB, context.vertexA)){

					if (context.slope == 0 && context.vertexB.x == Math.floor(context.vertexB.x)){
						context.vertexB.x--;
					}
					try_emit(context.vertexB, emit_fragment);
				}
			}



			// // if we crossed the diamond and we are outside, we emit
			// if (DoesLineCrossDiamond({start: context.vertexA, end: context.vertexB}, context.vertexB) && IsOutsideDiamond(GetManhattanDistance(context.vertexB))){
			// 	console.log("END: CROSS")
			// 	try_emit(context.vertexB, emit_fragment);
			// }
			// else if (IsOnDiamondBottom(context.vertexB)){
			// 	try_emit(context.vertexB, emit_fragment);
			// }
			// else if (IsOnDiamondLeft(context.vertexB) && !context.iteratingX){
			// 	console.log("slope steep")
			// 	const pixelLeftOfVertexB = {x: context.vertexB.x - 1, y: context.vertexB.y}
			// 	try_emit(pixelLeftOfVertexB, emit_fragment);
			// }
			// else{
			// 	const current_b = Math.floor(context.slope * (current_a - context.iterating.start) + context.adjusting.start) + 0.5;

			// 	const vertex = context.iteratingX ? {x: current_a, y: current_b} : {x: current_b, y: current_a};

			// 	console.log("vertex: ", vertex)

			// 	if (!context.iteratingX && context.slope == 0 && context.vertexA.x == Math.floor(context.vertexA.x)){
			// 		vertex.x--;
			// 	}

			// 	if (vertex.x <= context.vertexA.x || vertex.y <= context.vertexA.y){
					
			// 		try_emit(vertex, emit_fragment);
			// 	}
			// 	else {

			// 		// we're not in the starting square
			// 		console.log(" last: stopped bad emit at: ", vertex)
			// 	}
				
			// }

			return;
		}
		else {

			const current_b = Math.floor(context.slope * (current_a - context.iterating.start) + context.adjusting.start) + 0.5;

			const vertex = context.iteratingX ? {x: current_a, y: current_b} : {x: current_b, y: current_a};

			if (!context.iteratingX && context.slope == 0 && context.vertexA.x == Math.floor(context.vertexA.x)){
				vertex.x--;
			}
			try_emit(vertex, emit_fragment);
		}
	
	}

}

</script>
<style>
html, body, h1, h2, p { padding: 0; margin: 0; }
html { border-top:25px solid #b00; }
body {
	font-family: 'Open Sans', sans-serif;
	font-style: normal;
	font-size: 12pt;
	font-weight: 400;
	color: #000;
	padding: 0 2em 0 2em;
}

h1, h2 {
	font-size: 24pt;
	font-weight: 700;
	margin:0 auto 14px auto;
}
h1 { text-transform: uppercase; margin-bottom: 5px; }
h2 { font-size: 16pt; }

p, h1, h2 { max-width: 700px; }
p { 
	color: #505050;
	margin:0 auto 1em auto;
}

.highlight { color: #b00; }

</style>
</head>
<body>

<h1>Line Rasterization</h1>
<h2>CMU 15-462/662 Fall 2022 | <span class="highlight">Mini-HW</span></h2>

<p>
Click and drag on the points to change the lines being rasterized.
If the page seems to hang, check your rasterization function for infinite loops.
</p>

<p>
You may find that your browser's developer tools are useful for debugging.
The vertices and fragments are available in the global variables <code>VERTICES</code> and <code>FRAGMENTS</code>, respectively.
</p>

<p>
Grey fragments were emitted by your <code>rasterize_line</code> function exactly once.
Red fragments were emitted more than once (the redder the fragment, the more times it was emitted).
This is generally bad.
</p>

<div id="wrapper">
<canvas id="canvas"></canvas>
</div>

<script>
"use strict";
//-----------------------------------------------------------------
//Code that connects your 'rasterize_line' function to the canvas.
//no need to modify this code.

const WRAPPER = document.getElementById('wrapper');
const CANVAS = document.getElementById('canvas');
const CTX = CANVAS.getContext('2d');

//canvas will be PX_WIDTH x PX_HEIGHT with a PX_MARGIN margin on all sides
const PX_MARGIN = 0.25;
const PX_WIDTH = 16;
const PX_HEIGHT = 16;
let PX_SIZE = 5.0;

const VERTEX_RADIUS = 0.1;

let vertexIndex = 0;

let test1 = [
	{x: 0.5, y: 15.5},
	{x: 1.5, y: 15.375}
];

let test2 = [
	{x: 1.5, y: 13.375},
	{x: 0.5, y: 13.5}
];


let VERTICES = test1;




let allVertices = [
	test1,
	test2
]
VERTICES.dirty = true; //dirty flag controls whether rasterize gets called next draw()

//fragments emitted by last rasterization:
let FRAGMENTS = {};

let HOVERED_VERTEX = null; //reference to object in VERTICES
let DRAGGING = null; //{vertex: , dx:, dy:} -- vertex + relative mouse position

let MOUSE = { };

function setMouse(evt) {
	const rect = CANVAS.getBoundingClientRect();
	//to canvas pixels:
	MOUSE.x = (evt.clientX - rect.left) / rect.width * CANVAS.width;
	MOUSE.y = (evt.clientY - rect.bottom) / -rect.height * CANVAS.height;
	//to PX space:
	MOUSE.x = (MOUSE.x / PX_SIZE) - PX_MARGIN;
	MOUSE.y = (MOUSE.y / PX_SIZE) - PX_MARGIN;
}

window.addEventListener('mousemove', function(evt){
	evt.preventDefault();
	const from = {x:MOUSE.x, y:MOUSE.y};
	setMouse(evt);
	if (DRAGGING) {
		const old = {x:DRAGGING.vertex.x, y:DRAGGING.vertex.y};
		DRAGGING.vertex.x = DRAGGING.dx + MOUSE.x;
		DRAGGING.vertex.y = DRAGGING.dy + MOUSE.y;
		DRAGGING.vertex.x = Math.round(DRAGGING.vertex.x * 8.0) / 8.0;
		DRAGGING.vertex.y = Math.round(DRAGGING.vertex.y * 8.0) / 8.0;
		DRAGGING.vertex.x = Math.max(0, Math.min(PX_WIDTH, DRAGGING.vertex.x));
        DRAGGING.vertex.y = Math.max(0, Math.min(PX_HEIGHT, DRAGGING.vertex.y));
		if (DRAGGING.vertex.x != old.x || DRAGGING.vertex.y != old.y)  {
			VERTICES.dirty = true;
		}
	} else {
		HOVERED_VERTEX = null;
		let dis2 = 1.5 * 1.5 * VERTEX_RADIUS * VERTEX_RADIUS; //Infinity;
		for (let vertex of VERTICES) {
			const test = (vertex.x-MOUSE.x)*(vertex.x-MOUSE.x) + (vertex.y-MOUSE.y)*(vertex.y-MOUSE.y);
			if (test < dis2) {
				HOVERED_VERTEX = vertex;
				dis2 = test;
			}
		}
	}
	requestDraw();
	return false;
});

window.addEventListener('mousedown', function(evt){
	evt.preventDefault();
	setMouse(evt);
	if (!DRAGGING && HOVERED_VERTEX) {
		DRAGGING = {
			vertex:HOVERED_VERTEX,
			dx:HOVERED_VERTEX.x - MOUSE.x,
			dy:HOVERED_VERTEX.y - MOUSE.y
		};
	}
	return false;
});

window.addEventListener('mouseup', function(evt){
	evt.preventDefault();
	setMouse(evt);
	if (DRAGGING) {
		DRAGGING = null;
	}
	requestDraw();
	return false;
});

window.addEventListener('keydown', function(evt){
	console.log("key: ", evt.key)

	if (evt.key == 'n'){
		vertexIndex++;
		VERTICES = allVertices[vertexIndex];
		VERTICES.dirty = true;
		requestDraw();
	}
});


function resized() {
	//resize the canvas's underlying context if its shape changes
	const style = getComputedStyle(CANVAS);
	let size = {x:WRAPPER.clientWidth, y:WRAPPER.clientHeight};
	size.x -= parseInt(style.getPropertyValue("padding-left")) + parseInt(style.getPropertyValue("padding-right"));
	size.y -= parseInt(style.getPropertyValue("padding-top")) + parseInt(style.getPropertyValue("padding-bottom"));

	//compute pixel size to fill canvas nicely:
	PX_SIZE = Math.max(10, size.x / (PX_WIDTH + 2.0 * PX_MARGIN));
	PX_SIZE *= window.devicePixelRatio;

	size.x = Math.floor( PX_SIZE * (PX_WIDTH + 2.0 * PX_MARGIN) );
	size.y = Math.floor( PX_SIZE * (PX_HEIGHT + 2.0 * PX_MARGIN) );

	if (CANVAS.width != size.x || CANVAS.height != size.y) {
		CANVAS.width = size.x;
		CANVAS.height = size.y;
		CANVAS.style.width = (size.x / window.devicePixelRatio) + "px";
		CANVAS.style.height = (size.y / window.devicePixelRatio) + "px";
		requestDraw();
	}
}

resized();

window.addEventListener('resize', resized);

function rasterize() {
	delete VERTICES.dirty;

	//clear fragments:
	FRAGMENTS = {};

	function emit_fragment(x,y) {
		if (Math.floor(x) + 0.5 != x || Math.floor(y) + 0.5 != y) {
			console.warn(`emit_fragment called with ${x},${y}, which is not a pixel center.`);
			return;
		}
		const key = Math.floor(x) + "." + Math.floor(y);
		if (!(key in FRAGMENTS)) {
			FRAGMENTS[key] = { x:x, y:y, count:1 };
		} else {
			FRAGMENTS[key].count += 1;
		}
	}
	
	for (let i = 1; i < VERTICES.length; ++i) {
		//make a copy so rasterize_line can't write vertex positions through sloppy coding:
		const va = {x: VERTICES[i-1].x, y: VERTICES[i-1].y};
		const vb = {x: VERTICES[i].x, y: VERTICES[i].y};

		rasterize_line(va, vb, emit_fragment);
	}
}

function draw() {
	if (VERTICES.dirty) rasterize();

	//clear:
	CTX.setTransform(1,0, 0,1, 1,1);
	CTX.fillStyle = '#eee';
	CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

	//go into pixel grid space:
	// (lower-left origin)
	CTX.setTransform(PX_SIZE,0, 0,-PX_SIZE, PX_SIZE * PX_MARGIN, PX_SIZE * (PX_HEIGHT + PX_MARGIN));

	//for 1layout-px lines, need to draw at:
	const px = window.devicePixelRatio / PX_SIZE;

	//shade fragments:
	for (const key in FRAGMENTS) {
		const fragment = FRAGMENTS[key];
		const R = 0.5;
		if (fragment.count == 1) {
			CTX.fillStyle = '#888';
		} else {
			let amt = 1.0 - Math.pow(0.9, fragment.count);
			let R = (1.0 - 0.5) * amt + 0.5;
			let G = (0.0 - 0.3) * amt + 0.3;
			let B = (0.0 - 0.3) * amt + 0.3;
			CTX.fillStyle = `rgb(${Math.round(255*R)},${Math.round(255*G)},${Math.round(255*B)})`;
		}
		CTX.fillRect(fragment.x-R, fragment.y-R, 2*R, 2*R);
	}

	//diamonds:
	CTX.beginPath();
	for (let y = 0; y < PX_HEIGHT; ++y) {
		for (let x = 0; x < PX_WIDTH; ++x) {
			CTX.moveTo(x + 0.5, y + 0.0);
			CTX.lineTo(x + 1.0, y + 0.5);
			CTX.lineTo(x + 0.5, y + 1.0);
			CTX.lineTo(x + 0.0, y + 0.5);
			CTX.closePath();
		}
	}
	CTX.strokeStyle = '#0002';
	CTX.lineWidth = px;
	CTX.stroke();

	//basic grid:
	CTX.strokeStyle = '#0008';
	CTX.lineWidth = px;
	CTX.beginPath();
	for (let x = 0; x <= PX_WIDTH; ++x) {
		CTX.moveTo(x, 0.0);
		CTX.lineTo(x, PX_HEIGHT);
	}
	for (let y = 0; y <= PX_HEIGHT; ++y) {
		CTX.moveTo(0.0, y);
		CTX.lineTo(PX_WIDTH, y);
	}
	CTX.stroke();

	//lines:
	CTX.strokeStyle = '#f88';
	CTX.lineWidth = 4.0 * px;
	CTX.beginPath();
	for (let x = 1; x < VERTICES.length; ++x) {
		CTX.moveTo(VERTICES[x-1].x, VERTICES[x-1].y);
		CTX.lineTo(VERTICES[x].x, VERTICES[x].y);
	}
	CTX.stroke();

	//line vertices:
	//TODO: nice circles at vertices!
	const radius = VERTEX_RADIUS;
	var first = true;
	for (let vertex of VERTICES) {
		CTX.fillStyle = '#06b5ff';
		if (vertex == HOVERED_VERTEX) {
			CTX.fillStyle = '#ff8';
		}

		if (first){
			CTX.fillStyle = '#ff06b5';
			first = false;
		}
		CTX.fillRect(vertex.x-radius, vertex.y-radius, 2*radius, 2*radius);
	}

	/*//DEBUG: mouse cursor
	CTX.beginPath();
	CTX.moveTo(MOUSE.x-0.5, MOUSE.y-0.5);
	CTX.lineTo(MOUSE.x+0.5, MOUSE.y+0.5);
	CTX.moveTo(MOUSE.x-0.5, MOUSE.y+0.5);
	CTX.lineTo(MOUSE.x+0.5, MOUSE.y-0.5);
	CTX.strokeStyle = '#000';
	CTX.lineWidth = 1.0 * px;
	CTX.stroke();
	*/


}

function requestDraw() {
	if (requestDraw.requested) return;
	requestDraw.requested = true;
	window.requestAnimationFrame(() => {
		requestDraw.requested = false;
		draw();
	});
}

requestDraw();

</script>
</body>
</html>
